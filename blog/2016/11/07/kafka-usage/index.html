<!DOCTYPE html>
<html lang="en-us">
  
  <head>
  <title>Kafka使用 - 清园索道</title>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
  <meta name="author" content="Xuancong Lee" />
    <meta name="description" content="kafka使用随笔" />
    <meta name="keywords" content="kafka,usage" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <link rel="stylesheet" href="/media/css/main.css" type="text/css">
  <link rel="stylesheet" href="/media/css/base16-ocean.light-min.css" type="text/css">
  <link href='https://fonts.googleapis.com/css?family=Fira+Sans' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Fira+Mono' rel='stylesheet' type='text/css'>
</head>

  <body>
    <div id="page-wrap">
      <div>
  <header id="header">
    <div class="logo">
      <h1><a href="/"><span class="logo-black">清园索道</span></a></h1>
    </div>
    <div class="fortune">
      <blockquote>
        上下求索，识己识人识事
      </blockquote>
    </div>
    <ul id="main-nav">
        <li><a href="/blog/">Blog</a></li>
      <li><a href="/tags/">分类</a></li>
      <li><a href="/about/">关于我</a></li>
      <li><a href="https://github.com/congleetea">GitHub</a></li>
      <li><a href="/rss.xml">RSS</a></li>
    </ul>
  </header>
</div>

      <article id="content">
        
  <h1>Kafka使用</h1>


<div id="outline-container-org768f9cb" class="outline-2">
<h2 id="org768f9cb">部署和使用</h2>
<div class="outline-text-2" id="text-org768f9cb">
<p>
一个生产的配置
</p>
<div class="org-src-container">
<pre class="src src-text"># ZooKeeper
zookeeper.connect=[list of ZooKeeper servers]

# Log configuration
num.partitions=8
default.replication.factor=3
log.dir=[List of directories. Kafka should have its own dedicated disk(s) or SSD(s).]

# Other configurations
broker.id=[An integer. Start with 0 and increment by 1 for each new broker.]
listeners=[list of listeners]
auto.create.topics.enable=false
min.insync.replicas=2
queued.max.requests=[number of concurrent requests]
</pre>
</div>
</div>
</div>

<div id="outline-container-org766a75c" class="outline-2">
<h2 id="org766a75c">升级</h2>
</div>

<div id="outline-container-org2b15af6" class="outline-2">
<h2 id="org2b15af6">集群之间迁移数据</h2>
<div class="outline-text-2" id="text-org2b15af6">
<p>
&gt; bin/kafka-mirror-maker.sh
--consumer.config consumer.properties
--producer.config producer.properties --whitelist my-topic
</p>
</div>
</div>

<div id="outline-container-orgdd22824" class="outline-2">
<h2 id="orgdd22824">扩大集群</h2>
<div class="outline-text-2" id="text-orgdd22824">
<ul class="org-ul">
<li>添加broker到集群很简单，就是分配一个独立的broker id并启动即可(connect同一个zk的都属于同一个cluster)。</li>
<li>新增的broker不会自动分配任何数据的分区，除非分区本移动到新broker上，否则如果没有新的topic创建，他就什么也不做, 因此需要迁移已有数据到新broker上。</li>
</ul>
</div>
</div>


<div id="outline-container-orgd45b902" class="outline-2">
<h2 id="orgd45b902">监控</h2>
<div class="outline-text-2" id="text-orgd45b902">
<ul class="org-ul">
<li>建议监控服务器端的GC time，CPU使用，IO服务时间等。</li>
<li>建议监控客户端的全局的和单个topic的消息byte rate，</li>
</ul>
</div>
</div>

<div id="outline-container-org08408fd" class="outline-2">
<h2 id="org08408fd">开始的问题</h2>
<div class="outline-text-2" id="text-org08408fd">
<p>
一开始听人说 kafka 是一个很牛逼的消息系统，所以有下面的一些问题，带着问题去看可能好一点。
</p>
<ul class="org-ul">
<li>kafka 和其他消息队列有什么不同</li>
</ul>
<p>
目前市面上有好些消息系统，比如 RabbitMQ，Redis，ZeroMQ,ActiveMQ,Kafka/Jafka，他们各有什么特点，
kafka 和他们有什么不同的地方?
</p>
<ul class="org-ul">
<li>为什么他的吞吐这么牛逼</li>
</ul>
<p>
kafka 的消息吞吐量可以达到 10W/s，为什么会有这样的能力?
</p>
<ul class="org-ul">
<li>整套系统的框架</li>
</ul>
<p>
kafka 有 Broker，Producer 和 Consumer，以及一个对整体进行管理的 Zookeeper，他们各自扮演什么角色，
又是怎么联系起来的？
</p>
<ul class="org-ul">
<li>如何使用</li>
</ul>
<p>
最后就是怎么使用这个东西？怎么监控它的运行情况？
</p>
</div>
</div>

<div id="outline-container-orgc01f982" class="outline-2">
<h2 id="orgc01f982">kafka 概要</h2>
<div class="outline-text-2" id="text-orgc01f982">
<p>
先要明白几个和消息相关的概念，明白这些概念也就对整体有个了解了：
</p>
<ul class="org-ul">
<li>话题 Topic</li>
</ul>
<p>
Topic把Kafka中流通的消息进行分类, 它算是消息的载体。生产者把消息发送到对应的Topic上，消费者从这个
Topic获取消息进行处理。和其它大部分系统的topic一样，一个topic可以被0,1或者多个订阅者订阅使用。但
不同的是：在比如mqtt，rabbitmq等broker中，一个topic上同时只能有一条消息，后面的消息会把前面的消息
覆盖，但是kafka中的消息则会被保留起来，类似数据库，但是毕竟是一个broker，数据不可能一致留着占用资
源，因此可以通过设置消息产生时间期限和消息的数量大小限制来删除旧的消息。
</p>

<ul class="org-ul">
<li>分区 Partition</li>
</ul>
<p>
由于 kafka 中 topic 的特殊性，一个topic可能会接收到来自生产者的大量的消息，所以一个topic会承受很
大的压力, 因此在创建一个topic的时候会指定把这个topic分成几个区(Partition)，每个分区都有在这个
<b>topic粒度上</b> 的唯一编号，Producer 在发送消息的时候会由Producer对消息做 <b>某种决策(或者说路由分流)</b> ，
将这条消息归到某个分区。topic 的分区如下图所示。
</p>


<div id="org2127caf" class="figure">
<p><img src="/assets/blog/2016/11/07/kafka-usage/log_anatomy.png" alt="log_anatomy.png" />
</p>
<p><span class="figure-number">Figure 1: </span>Topic Partitions</p>
</div>

<p>
<b>Producer 确定某条消息该发往哪个Partition 的方法主要有两种</b> ，一个是随机确定，另一个是通过消息的一
个key来利用hash算法确定，通常的做法是 <b>(hash(key) rem partition_num)</b> 的结果作为选择的分区(所以
Producer首先要知道共有多少分区, zookeeper负责该功能)。这样通过分区就可以实现负载均衡, 增加kafka
的读写能力。
</p>

<ul class="org-ul">
<li>分段 Segment</li>
</ul>
<p>
每个broker上 <b>给每个Partition都会产生一个目录</b> ，该目录下面保存这发往这个分区的消息。消息是按照顺
序存入磁盘的，但并不是作为一个文件保存在这个目录下面的，而是 <b>分段保存成一个个文件(segment 文件)</b> ，
每个segment以该segment的第一条消息的offset命名, 比如第一个文件是00000000000000000000.log，下一个
文件接着该文件最后一条消息的偏移往下排。kafka 中可以设置一些参数来控制 <b>什么时候新建segment</b> ， 
<b>什么时候删除旧的segment</b> ， <b>后台会有线程隔多久检查一次</b> ，决定相关的处理。Partition 内的segment
如下图所示。
</p>


<div id="orgebdeef8" class="figure">
<p><img src="/assets/blog/2016/11/07/kafka-usage/log_segment.png" alt="log_segment.png" />
</p>
<p><span class="figure-number">Figure 2: </span>Topic partition 内的分段 segments 文件结构示例</p>
</div>

<ul class="org-ul">
<li>顺序写磁盘</li>
</ul>
<p>
Kafka是通过顺序写磁盘来持久化数据的，一般来说磁盘的操作效率是很低的，肯定很难得到这么高的吞吐量，但是 
有人测试过顺序写磁盘有时候比随机写内存还要快。这种 <b>顺序写磁盘的方式正式kafka高吞吐的一个重要原因</b> 。  
</p>

<p>
kafka <b>给每条消息都会置一个相对这个Partition第一条消息的偏移(offset)</b> 。给每一条消息都编号并按顺序append
到上一条消息后面，这也方便Consumer更方便地消费数据。
</p>

<ul class="org-ul">
<li>消费方式 push vs pull</li>
</ul>
<p>
大部分消息系统的消费有两种方式：push vs pull。前者是服务器一有消息就直接推送给Consumer，不管 Consumer 
目前有没有能力处理；pull则是Consumer有能力处理的时候自动向broker拉取消息，如果broker没有消息就会等待
消息的到来。 <b>kafka的设计是生产者向broker push消息，而消费者向broker pull消息</b> 。这样消息的使用决定权在
Consumer，所以不太会因为消息压力太大把Consumer搞挂。
</p>

<p>
同时，由于消息存储的时候有一个offset值， <b>Consumer消费的时候也可以维持消费到的offset值，按顺序消费</b> ，
这样消费速度就会更快。当然如果消费者想消费已经消费过的消息，只要Consumer改变这个值就可重复消费了。
</p>


<div id="org6b17c18" class="figure">
<p><img src="/assets/blog/2016/11/07/kafka-usage/log_consumer.png" alt="log_consumer.png" />
</p>
<p><span class="figure-number">Figure 3: </span>Consumer 带 offset 消费消息</p>
</div>

<ul class="org-ul">
<li>消费组 Consumer Group</li>
</ul>
<p>
kafka通过消费组把Consumer归在某些组里面，实现broker上消息对Consumer的单播和广播。 <b>原则是一条消息只
要被一个组里面的一个 Consumer 消费，就不会再给这个组的其他成员了</b> 。这样如果我们要对所有Consumer 广播，那就
他们单独成一个组，如果单播，就把多个 Consumer 放在一个 Group 里面。
</p>

<ul class="org-ul">
<li>复本集 Replicas</li>
</ul>
<p>
为容错性考虑，避免因为一个 broker 挂了就无法正常工作的情况，通常在使用时会将多个broker布置为一个cluster。
首先，这种考虑可以真正的实现负载均衡，让多个broker来分担压力；其次，一个Partition写到一个broker上，
一旦这个broker挂了，数据就可能丢失了。因此kafka <b>在Partition粒度上设置复制集</b> 。我们在建立topic的时候也
会设置一个Replicas个数的参数，那么这个 topic 的所有分区都会有这么多个副本(注意并不是所有broker上都有所有
Partition的副本)，而且这些副本分散在不同的broker上，即使一个broker挂了或者不工作了，还有另外的broker保存
相同的数据，可以保证数据不丢失。
</p>

<p>
一个 <b>Partition 的所有副本集中</b> 有一个是leader，其他是follower。 <b>Producer向cluster推送消息和Consumer从
broker拉取消息都只和leader交互</b> ， <b>然后follower像Consumer消费数据一样从leader上拷贝数据</b> 。
</p>

<ul class="org-ul">
<li>In-Sync Replicas (ISR)</li>
</ul>
<p>
和大部分分布式系统一样，要自动处理故障就必须对一个节点node的"alive"有一个精确的定义。kafka的存活node(也就
是In Sync node)需要满足两个条件：
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-left">node必须和zookeeper之间通过心跳维持session</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-left">slave node必须复制leader上发生的写操作，并且不会落后leader太远</td>
</tr>
</tbody>
</table>

<p>
leader会跟踪Partition的ISR集合(就是一个记录In Sync的列表)，如果某个follower挂了或者同步数据落后了，leader就
会把这个node从ISR列表中删除, 确定node挂了或者数据落后由参数replica.lag.time.max.ms确定。
</p>

<p>
<b>如果一条消息被所有ISR节点写入各自的log，那么这个消息就是commited的消息，只有这样的消息才会给Consumer使用</b> , 
也就是说Consumer看到的消息一定不会因为leader失效而丢失； <b>另一方面，用户可以设置是否让Producer等待它发送的
消息被标记为commited</b> (request.required.acks设置)，这就需要在数据延迟和数据持久性上做出权衡了(做法是通过Producer使用ack来判断)。
</p>

<p>
Producer把一条消息发送到该Partition的leader之后，只有所有ISR都把这条消息写入log，然后给出ack确认之后这条消
息才叫commited的，此外leader的最后一条消息的offset叫做log end offset（LEO）。 当一个ISR的offset和leader的
LEO差值大于某个值（通过replica.lag.max.messages设置）时，这个broker就会被从ISR列表中剔除。 <b>此时follower还
可以从leader上复制数据(其实就是消费数据)，当数据差值符合条件是还会被添加到ISR列表中.</b> 
</p>

<p>
需要注意的是ISR的数量并不是和该Partition的Replicas个数一样的，ISR数量是可以配置的， <b>这样就只需要有这个数量
的副本集对消息进行确认，消息才能认为是commited的。</b>
</p>


<div id="orge19ec94" class="figure">
<p><img src="/assets/blog/2016/11/07/kafka-usage/isr.png" alt="isr.png" />
</p>
<p><span class="figure-number">Figure 4: </span>ISR 确认消息</p>
</div>

<ul class="org-ul">
<li>Kafka 对消息投递的保障</li>
</ul>
<p>
kafka 提供消息投递过程中的一些保证：
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-left">发送到同一个 partition 的消息会按序加在前一条消息后面。</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-left">消费者会按序得到保存的消息</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left">对于 replication factor 为 N 的 topic，我们可以实现 N-1 个服务器故障而不丢失任何提交的数据。</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>如何管理整个系统--zookeeper</li>
</ul>
<p>
它是一个快速、高可用、容错、分布式的协调服务。你可以使用 ZooKeeper 构建可靠的、分布式的数据结构，用于群组
成员、leader选举、协同工作流和配置服务，以及广义的分布式数据结构如锁、队列、屏障（Barrier）和锁存器（Latch）。
许多知名且成功的项目依赖于 ZooKeeper，其中包括 HBase、Hadoop 2.0、Solr Cloud、Neo4J、Apache Blur（Incubating）
和 Accumulo。
</p>

<p>
Kafka将元数据信息保存在Zookeeper中，但是 <b>发送给Topic本身的数据是不会发到Zk上的</b> ，否则Zk就疯了。 <b>kafka
使用zookeeper来实现动态的集群扩展</b> ，不需要更改客户端（producer和consumer）的配置。 <b>broker会在zookeeper
注册并保持相关的元数据（topic，partition信息等）更新</b> 。 而 <b>客户端会在zookeeper上注册相关的watcher</b> 。一
旦zookeeper发生变化，客户端能及时感知并作出相应调整。 这样就保证了添加或去除broker时，各broker间仍能自动
实现负载均衡。这里的客户端指的是Kafka的消息生产端(Producer)和消息消费端(Consumer), <b>Producer端使用zookeeper
用来"发现"broker列表</b> ,以及和Topic下每个partition的leader建立socket连接并发送消息。也就是说每个Topic的partition
是由leader角色的Broker端使用zookeeper来注册broker信息,以及监测partition leader存活性。 <b>Consumer端使用
zookeeper用来注册consumer信息</b> ,其中包括consumer消费的partition列表等,同时也用来发现broker列表,并和partition leader
建立socket连接,并获取消息。
</p>


<div id="org12d6d6c" class="figure">
<p><img src="/assets/blog/2016/11/07/kafka-usage/zookeeper_in_kafka.png" alt="zookeeper_in_kafka.png" />
</p>
<p><span class="figure-number">Figure 5: </span>zookeeper中的信息</p>
</div>
</div>
</div>

<div id="outline-container-orgeb47d1d" class="outline-2">
<h2 id="orgeb47d1d">安装</h2>
<div class="outline-text-2" id="text-orgeb47d1d">
<p>
kafka 需要 java-jdk 提供支持，同时还需要 zookeeper 来对集群进行管理。因此需要安装这些东西。
</p>
</div>

<div id="outline-container-org17ee24d" class="outline-3">
<h3 id="org17ee24d">安装 java jdk</h3>
<div class="outline-text-3" id="text-org17ee24d">
<ul class="org-ul">
<li>在<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">这里</a> 下载 Linux 的 jdk，根据 Linux系统的位数选择，这里以后缀为.tar.gz的为例，.rpm的直接安装就是。</li>

<li>解压。</li>

<li>把解压后的文件夹放到/usr/local 下面。（这个随便，任意目录下都可以）</li>

<li>在主目录下找到隐藏文件.profile ,  若没有.profile，则去找文件 .bash_profile （注意文件名以点号开头，因为是隐藏文件）。</li>

<li>在文件.profile 或 .bash_profile 中添加环境变量，在文件的最末尾加上以下4行(需根据具体情况修改，由JAVA所在目录决定)：</li>
</ul>

<div class="org-src-container">
<pre class="src src-shell">export  JAVA_HOME = /usr/local/jdk1.8.0
export  JRE_HOME = ${JAVA_HOME}/jre
export  CLASSPATH = .:${JAVA_HOME}/lib:${JRE_HOME}/lib
export  PATH = ${JAVA_HOME}/bin:$PATH
</pre>
</div>

<p>
若添加正确，注销或重启计算机以后，在Bash Shell中输入：
</p>

<div class="org-src-container">
<pre class="src src-shell">$ java   -version
$ javac   -version
</pre>
</div>

<p>
都会显示版本信息。
</p>
</div>
</div>

<div id="outline-container-orgfa4e925" class="outline-3">
<h3 id="orgfa4e925">安装 zookeeper</h3>
<div class="outline-text-3" id="text-orgfa4e925">
<p>
在<a href="http://apache.01link.hk/zookeeper/stable/zookeeper-3.4.9.tar.gz">zookeeper</a> 这里下载最新的 zookeeper 二进制文件，解压之后即可使用。
</p>
</div>
</div>
<div id="outline-container-orgfd4a949" class="outline-3">
<h3 id="orgfd4a949">安装 kafka</h3>
<div class="outline-text-3" id="text-orgfd4a949">
<p>
在<a href="https://mirrors.tuna.tsinghua.edu.cn/apache/kafka">这里</a> 选择最新版本的 kafka 二进制文件包下载，解压到你的某个文件即可使用。
</p>
</div>
</div>
</div>

<div id="outline-container-orge8e6062" class="outline-2">
<h2 id="orge8e6062">使用概况</h2>
<div class="outline-text-2" id="text-orge8e6062">
</div>
<div id="outline-container-org4f74614" class="outline-3">
<h3 id="org4f74614">Kafka 作为 messaging system</h3>
<div class="outline-text-3" id="text-org4f74614">
<p>
传统的消息系统有两种模式：queuing 和 publish-subscribe。 在 queuing 中，Consumer 池子中只有一个 Consumer
能得到这个消息，他得到消息之后，消息就会被删除，其他 Consumer 无法获得；而 publish-subscribe 模式则是所有
订阅的 Consumer 都会收到同样的消息。Kafka 引入了 Consumer Group 的概念可以同时实现上面两种类型。
</p>

<p>
此外，kafka 相比传统的消息系统在时序方面有较强的保证。传统的队列在服务器端按序保存消息，多个消费者从这个
队列取消息的时候，尽管服务器是按是按顺序给出的，但是消息是异步投递给消费者的，所以他们可能不会按顺序到达不同的
消费者，这意味这在并行处理的时候消息还是会混乱。于是小系统常常通过一种叫"独占消费"(exclusive consumer)的
变通方式来允许一个进程消费一个队列，这也就不是并行处理了。Kafka 在这方面做的很好，他通过 topic 分区 partition 
的概念来实现在分区内部的时序。这样我们可以确保某个Consumer是这个partition的唯一reader，自然就可以按时序消
费消息。但是注意，消费者的个数不能高于partition的个数。
</p>
</div>
</div>

<div id="outline-container-org58793f8" class="outline-3">
<h3 id="org58793f8">Kafka 作为 storage system</h3>
<div class="outline-text-3" id="text-org58793f8">
<p>
消息队列可以作为一个飞行消息的存储系统，通过保存消息可以把消息的发布和消费进行解耦。Kafka是一个好的存储系统，
他有什么不同呢？
</p>

<p>
数据写入 kafka 是写入到磁盘的，同时为了实现容错而进行复制。kafka 允许 producers 等待 ack 确认消息，这样只有当
这条消息被完全复制才会任务消息写入完成，这样就保证了持久化。前面已经讲到，kafka的按序存储方式决定了他的操作和
数据的大小没有关系。
</p>
</div>
</div>

<div id="outline-container-org354cf3f" class="outline-3">
<h3 id="org354cf3f">Kafka 作为消息处理系统</h3>
<div class="outline-text-3" id="text-org354cf3f">
<p>
只有消息的读写和存储有时候还不够，还需要实现消息的实时处理。Kafka 是一个消息流处理器。它从输入 topics 上获得连续的
数据流，执行一些处理之后产生连续的数据流到输出 topics。
</p>

<p>
虽然我们可以使用 producer APIs 和 Consumer APIs 直接直线一些简单的处理，但是对于一些复杂的转换，Kafka 提供了
完整的 Streams API。这样就可以构建一个运用，不需要处理繁琐的步骤。
</p>
</div>
</div>

<div id="outline-container-orgdabc7a5" class="outline-3">
<h3 id="orgdabc7a5">使用例子</h3>
<div class="outline-text-3" id="text-orgdabc7a5">
<p>
<a href="https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying">The Log: What every software engineer should know about real-time data's unifying abstraction</a>
</p>

<p>
为了对使用有一个了解，我们设置三个节点的集群(单节点的集群就略过了)，首先要启动三个 server 节点：
复制 config/server.properties 文件为 config/server-1.properties，config/server-2.properties，修改如下：
</p>
<div class="org-src-container">
<pre class="src src-shell">config/server.properties:
broker.id=0
listeners=PLAINTEXT://:9092
log.dir=/tmp/kafka-logs

config/server-1.properties:
broker.id=1
listeners=PLAINTEXT://:9093
log.dir=/tmp/kafka-logs-1

config/server-2.properties:
broker.id=2
listeners=PLAINTEXT://:9094
log.dir=/tmp/kafka-logs-2
</pre>
</div>

<p>
然后要启动 zookeeper 后再启动这三个节点：
</p>
<div class="org-src-container">
<pre class="src src-shell">$./bin/zookeeper-server-start.sh config/zookeeper.properties 
[2016-11-08 15:12:28,204] INFO Reading configuration from: config/zookeeper.properties (org.apache.zookeeper.server.quorum.QuorumPeerConfig)
......
$ bin/kafka-server-start.sh config/server.properties
$ bin/kafka-server-start.sh config/server-1.properties
$ bin/kafka-server-start.sh config/server-2.properties
</pre>
</div>

<p>
启动完成之后我们创建一个 topic/队列, 名为 v1-r3-p3, 并给这个 topic 设定三个复制集，3 个 partitions：
</p>
<div class="org-src-container">
<pre class="src src-shell">$ bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 3 --partitions 3 --topic v1-r3-p3 
</pre>
</div>

<p>
现在我们看看三个节点各自扮演什么角色：
</p>
<div class="org-src-container">
<pre class="src src-shell">$ ./bin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic v1-r3-p3
Topic:v1-r3-p3	PartitionCount:3	ReplicationFactor:3	Configs:
Topic: v1-r3-p3	Partition: 0	Leader: 0	Replicas: 0,1,2	Isr: 0,1,2
Topic: v1-r3-p3	Partition: 1	Leader: 1	Replicas: 1,2,0	Isr: 1,2,0
Topic: v1-r3-p3	Partition: 2	Leader: 2	Replicas: 2,0,1	Isr: 2,0,1
</pre>
</div>
<p>
第一行指出这个 topic，有 3 个 partitions，3 个复制集。后面每个 partition 的情况，有多少 partition 就有多少行。
Replicas 是三个复制集，Isr 是"in-sync" replicas，两者的区别是，后者是前者的子集，Isr 只是当前活着的节点。
</p>

<p>
根据上面的信息，结合上一节的说明，节点 0 是 v1-r3-p3 的 partition 0 的 leader，同时是 partition 1 和 2 的 follower，
消息的 Producer 只和节点 0 交互，将数据写到节点 0，然后节点 1 和 2 会被动地从节点 0 复制数据。同理，另外两节点也各自
作为 partition1,2 的 leader，同时是其他两个的 follower。
</p>

<p>
下面我们启动一个 producer 和一个 Consumer：
</p>
<div class="org-src-container">
<pre class="src src-shell">$ bin/kafka-console-producer.sh --broker-list localhost:9092 --topic v1-r3-p3 
$ bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --from-beginning --topic v1-r3-p3 
</pre>
</div>
<p>
在 Producer 窗口我们可以输入一行内容，回车之后 Consumer 中可以显示出来。
</p>

<p>
此外在三个节点的 log 目录：/tmp/kafka-logs， /tmp/kafka-logs-1， /tmp/kafka-logs-2 目录下面我们会看到三个分区的目录：
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">v1-r3-p3-0</td>
</tr>

<tr>
<td class="org-left">v1-r3-p3-1</td>
</tr>

<tr>
<td class="org-left">v1-r3-p3-2</td>
</tr>
</tbody>
</table>
<p>
这里就只有一个是该节点作为主节点的分区内容，另外两个目录都是从该分区的 leader 上复制来的。
</p>

<p>
每个目录下面：
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">00000000000000000000.index</td>
</tr>

<tr>
<td class="org-left">00000000000000000000.log</td>
</tr>

<tr>
<td class="org-left">00000000000000000000.timeindex</td>
</tr>
</tbody>
</table>
<p>
00000000000000000000.log 就是 segment 文件，在配置文件中我们设置了单个 segment 文件的大小，超过这个大小就会创建新的 
segment 文件
</p>

<p>
接下来我们检验一下他的容错性，我们知道 Broker0 是 partition0 的 leader，如果我们把它杀死，会怎么样呢？
</p>
<div class="org-src-container">
<pre class="src src-shell">$ ps aux | grep server.properties
root     24241  0.0  0.0  72700  2336 pts/32   S+   15:48   0:00 sudo ./bin/kafka-server-start.sh config/server.properties
$ sudo kill 24241
$ bin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic v1-r3-p3
Topic:v1-r3-p3	PartitionCount:3	ReplicationFactor:3	Configs:
Topic: v1-r3-p3	Partition: 0	Leader: 1	Replicas: 0,1,2	Isr: 1,2
Topic: v1-r3-p3	Partition: 1	Leader: 1	Replicas: 1,2,0	Isr: 1,2
Topic: v1-r3-p3	Partition: 2	Leader: 2	Replicas: 2,0,1	Isr: 2,1
</pre>
</div>
<p>
现在我们看到原本 Partition0 的 leader 是节点 0，现在变成了节点 1 了，Replicas 还是没有变，但是 Isr 变了，杀死的节点
不在了。
</p>

<p>
但是 Producer 和 Consumer 依然工作的很好，尽管他们启动的时候指定的端口是节点 0 的端口。
</p>
</div>
</div>
</div>

<div id="outline-container-orgbf3706c" class="outline-2">
<h2 id="orgbf3706c">Kakfa 的监控</h2>
<div class="outline-text-2" id="text-orgbf3706c">
<p>
目前对 kafka 的监控程序有好几个，
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-left">KafkaOffsetMonitor</td>
<td class="org-left">This is an app to monitor your kafka consumers and their position (offset) in the queue.</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-left"><a href="https://github.com/Microsoft/Availability-Monitor-for-Kafka.git">Availability-Monitor-for-Kafka</a></td>
<td class="org-left">Availability monitor for Kafka allows you to monitor the end to end availability and latency for sending and reading data from Kafka.</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left"><a href="https://github.com/claudemamo/kafka-web-console.git">kafka-web-console</a></td>
<td class="org-left">This project is no longer supported. Please consider Kafka Manager instead.</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-left">kafka-monitor</td>
<td class="org-left">Kafka Monitor is a framework to implement and execute long-running kafka system tests in a real cluster.</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left"><a href="https://github.com/yahoo/kafka-manager">kafka-manager</a> [Yahoo]</td>
<td class="org-left">A tool for managing Apache Kafka.</td>
</tr>
</tbody>
</table>

<p>
前几个都没怎么更新了，比较新的是 <a href="https://github.com/linkedin/kafka-monitor.git">kafka-monitor</a> 是 LinkIn 支持的，kafka-manager 是 yahoo 支持的. 但是前者功能目前还很不完善。 
这里使用雅虎的 kafka-manager。
</p>

<p>
如果想要获得更详细的监控信息，需要在启动kafka的时候打开JMX端口，在kafka-manager创建集群的时候也打开JMX Polling。
在 kafka-server-start.sh中修改为：
</p>
<div class="org-src-container">
<pre class="src src-shell">if [ "x$KAFKA_HEAP_OPTS" = "x" ]; then
    export KAFKA_HEAP_OPTS="-Xmx1G -Xms1G"
    export JMX_PORT="9999"
fi
</pre>
</div>
<p>
就是加上export JMX_PORT="9999"
</p>

<ul class="org-ul">
<li>需要事先安装 java 环境。</li>
</ul>
<div class="org-src-container">
<pre class="src src-shell">$ git clone https://github.com/yahoo/kafka-manager.github
$ ./sbt clean dist #这个过程需要花费很长时间下载很多东西。
</pre>
</div>

<p>
安装完之后会产生安装二进制包，在 target/universal 文件夹里面，是一个 zip 文件包。
解压这个 zip 文件，修改 conf/application.conf 文件。
</p>
<div class="org-src-container">
<pre class="src src-java">kafka-manager.zkhosts="localhost:2181"
kafka-manager.zkhosts=${?ZK_HOSTS}
</pre>
</div>
<p>
指定 zookeeper 的 ip 和 host，如果不想硬编码，可以设置环境变量 ZK_HOSTS="localhost:2181"
</p>

<ul class="org-ul">
<li>启动</li>
</ul>
<div class="org-src-container">
<pre class="src src-shell">$ ./bin/kafka-manager
# 如果要使用特定的配置文件或者打开特定的端口可以使用下面的命令(默认端口是 9000)：
$ ./bin/kafka-manager -Dconfig.file=/path/to/application.conf -Dhttp.port=8080
# 如果 java 的路径不在 path 中，可以如下制定
$ bin/kafka-manager -java-home /usr/local/oracle-java-8
</pre>
</div>
<p>
完了就可以使用浏览器查看了。
</p>

<ul class="org-ul">
<li>新建 cluster</li>
</ul>
<p>
进入添加 cluster 界面，给集群一个命令，然后把 cluster 的 zookeeper 的 host 填好，
如果使用了多个 zookeeper，可以使用逗号隔开：
</p>
<div class="org-src-container">
<pre class="src src-shell">localhost:2181
</pre>
</div>

<ul class="org-ul">
<li>可以新建 topic</li>

<li>参数含义</li>
</ul>
<p>
preferred replica:
每个 partitiion 的所有 replicas 叫做"assigned replicas"，"assigned replicas"中的
第一个replicas叫"preferred replica"，刚创建的topic一般"preferred replica"是leader。
</p>
</div>
</div>

<div id="outline-container-org3b6cb71" class="outline-2">
<h2 id="org3b6cb71">重要的配置说明</h2>
<div class="outline-text-2" id="text-org3b6cb71">
</div>
<div id="outline-container-orgc5bae5e" class="outline-3">
<h3 id="orgc5bae5e">kafka配置</h3>
<div class="outline-text-3" id="text-orgc5bae5e">
<p>
必须要的配置：broker.id, log.dirs, zookeeper.connect
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">参数名</th>
<th scope="col" class="org-left">默认</th>
<th scope="col" class="org-left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">broker.id</td>
<td class="org-left">0</td>
<td class="org-left">该kafka node在集群中的唯一标识。如果没设置则自动根据reserved.broker.max.id + 1产生。</td>
</tr>

<tr>
<td class="org-left">advertised.host.name</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">替换为advertised.listeners, 只有当advertised.listeners  or listeners没有设置的时候才有用。</td>
</tr>

<tr>
<td class="org-left">advertised.port</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">替换为advertised.listeners, 只有当advertised.listeners  or listeners没有设置的时候才有用。</td>
</tr>

<tr>
<td class="org-left">advertised.listeners</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">这个listener会发布到zookeeper，然后client通过这个listener来连接broker, 如果未设置该项，默认将使用参数listener。在IaaS环境中，这个地址应该和broker绑定的地址不一样。</td>
</tr>

<tr>
<td class="org-left">auto.create.topics.enable</td>
<td class="org-left">true</td>
<td class="org-left">是否允许服务器自动创建topics。</td>
</tr>

<tr>
<td class="org-left">auto.leader.rebalance.enable</td>
<td class="org-left">true</td>
<td class="org-left">后台进程会定期检查并按需要触发leader的再平衡。</td>
</tr>

<tr>
<td class="org-left">background.threads</td>
<td class="org-left">int(10)</td>
<td class="org-left">用于各种后台任务的线程个数。</td>
</tr>

<tr>
<td class="org-left">compression.type</td>
<td class="org-left">string(producer)</td>
<td class="org-left">('gzip', 'snappy', 'lz4'),'uncompressed'(不压缩),'producer'(保留producer的原始压缩)</td>
</tr>

<tr>
<td class="org-left">delete.topic.enable</td>
<td class="org-left">false</td>
<td class="org-left">如果false，通过admin 工具也不能删除topic。</td>
</tr>

<tr>
<td class="org-left">host.name</td>
<td class="org-left">废止</td>
<td class="org-left">listener没有设置时有效, 如果设置将会bind这个host，否则绑定0.0.0.0。</td>
</tr>

<tr>
<td class="org-left">listeners</td>
<td class="org-left">string</td>
<td class="org-left">逗号隔开多个， 绑定的监听。PLAINTEXT://myhost:9092,SSL://:9091 CLIENT://0.0.0.0:9092,REPLICATION://localhost:9093</td>
</tr>

<tr>
<td class="org-left">leader.imbalance.check.interval.seconds</td>
<td class="org-left">long(300)</td>
<td class="org-left">controller检查分区再平衡的频率。</td>
</tr>

<tr>
<td class="org-left">leader.imbalance.per.broker.percentage</td>
<td class="org-left">int(10)</td>
<td class="org-left">每个broker不平衡比例超过这个百分比就会触发leader再平衡。</td>
</tr>

<tr>
<td class="org-left">log.dirs</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">保存kafka数据的目录。</td>
</tr>

<tr>
<td class="org-left">log.dir</td>
<td class="org-left">/tmp/kafka-logs</td>
<td class="org-left">补充log.dirs.</td>
</tr>

<tr>
<td class="org-left">log.flush.interval.messages</td>
<td class="org-left">9223372036854775807</td>
<td class="org-left">一个log分区累计消息条数到达该值时刷写到磁盘, 太小会使拷贝频繁，影响性能。</td>
</tr>

<tr>
<td class="org-left">log.flush.interval.ms</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">消息从内存拷贝到磁盘的时间间隔，未设置时使用log.flush.scheduler.interval.ms</td>
</tr>

<tr>
<td class="org-left">log.flush.offset.checkpoint.interval.ms</td>
<td class="org-left">int(60000)</td>
<td class="org-left">更新上次持久化消息(作为恢复点的消息)的频率。</td>
</tr>

<tr>
<td class="org-left">log.flush.scheduler.interval.ms</td>
<td class="org-left">long(9223372036854775807)</td>
<td class="org-left">log flusher检查log是否需要刷写到磁盘的频率。</td>
</tr>

<tr>
<td class="org-left">log.retention.bytes</td>
<td class="org-left">long(-1)</td>
<td class="org-left">log超过这个字节数之后就会被删除。</td>
</tr>

<tr>
<td class="org-left">log.retention.hours</td>
<td class="org-left">int(168)</td>
<td class="org-left">超过改时间的log 文件会被删除。</td>
</tr>

<tr>
<td class="org-left">log.retention.minutes</td>
<td class="org-left">int</td>
<td class="org-left">如果设置这个值，log.retention.hours就不会使用。</td>
</tr>

<tr>
<td class="org-left">log.retention.ms</td>
<td class="org-left">long</td>
<td class="org-left">如果设置这个值，log.retention.minutes就不会使用。</td>
</tr>

<tr>
<td class="org-left">log.roll.hours</td>
<td class="org-left">int(168)</td>
<td class="org-left">新建log文件的时间间隔。</td>
</tr>

<tr>
<td class="org-left">log.roll.ms</td>
<td class="org-left">long</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">log.segment.bytes</td>
<td class="org-left">int(1073741824)</td>
<td class="org-left">单个log文件的最大字节数, 超过会新建文件。</td>
</tr>

<tr>
<td class="org-left">log.segment.delete.delay.ms</td>
<td class="org-left">long(60000)</td>
<td class="org-left">等待从文件系统中删除一个文件的时间。</td>
</tr>

<tr>
<td class="org-left">message.max.bytes</td>
<td class="org-left">int(1000012)</td>
<td class="org-left">服务器能接受的最大消息大小。</td>
</tr>

<tr>
<td class="org-left">min.insync.replicas</td>
<td class="org-left">int(1)</td>
<td class="org-left">如果producer要求确认(参见producer参数acks)，至少要有这么多的复制集回应写入成功，如果达不到，producer会提示异常(NotEnoughReplicas or NotEnoughReplicasAfterAppend)</td>
</tr>

<tr>
<td class="org-left">num.io.threads</td>
<td class="org-left">int(8)</td>
<td class="org-left">服务器用于执行网络请求的io线程数量。</td>
</tr>

<tr>
<td class="org-left">num.network.threads</td>
<td class="org-left">int(3)</td>
<td class="org-left">服务器用于执行网络请求的网络线程数量。</td>
</tr>

<tr>
<td class="org-left">num.recovery.threads.per.data.dir</td>
<td class="org-left">int(1)</td>
<td class="org-left">给每个目录生成的进程数，用于启动时的log恢复或者在shutdown时的log刷写。</td>
</tr>

<tr>
<td class="org-left">num.replica.fetchers</td>
<td class="org-left">int(1)</td>
<td class="org-left">用来从source broker上复制消息的fetcher进程数量。太大会增加IO负担。</td>
</tr>

<tr>
<td class="org-left">offset.metadata.max.bytes</td>
<td class="org-left">int(4096)</td>
<td class="org-left">关联一个offset commit 的 metadata条目的最大字节数。</td>
</tr>

<tr>
<td class="org-left">offsets.commit.required.acks</td>
<td class="org-left">short(-1)</td>
<td class="org-left">一个commit被接受的必需acks数量，通常使用默认-1.</td>
</tr>

<tr>
<td class="org-left">offsets.commit.timeout.ms</td>
<td class="org-left">int(5000)</td>
<td class="org-left">offset提交的时间限制，除非这个offsets topic的所有复制集收到提交或该时间到达。</td>
</tr>

<tr>
<td class="org-left">offsets.load.buffer.size</td>
<td class="org-left">int(5242880)</td>
<td class="org-left">当从缓存加载offsets值时，从offsets segments读取的batch size。</td>
</tr>

<tr>
<td class="org-left">offsets.retention.check.interval.ms</td>
<td class="org-left">long(600000)(10min)</td>
<td class="org-left">检查陈旧的offsets的频率。</td>
</tr>

<tr>
<td class="org-left">offsets.retention.minutes</td>
<td class="org-left">int(1440)</td>
<td class="org-left">offsets(其实也是一个topic)保留的时间。</td>
</tr>

<tr>
<td class="org-left">offsets.topic.compression.codec</td>
<td class="org-left">int(0)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">offsets.topic.num.partitions</td>
<td class="org-left">int(50)</td>
<td class="org-left">offsets topic的默认分区数量。</td>
</tr>

<tr>
<td class="org-left">offsets.topic.replication.factor</td>
<td class="org-left">short(3)</td>
<td class="org-left">offsets topic的默认复制集个数, 高会更安全。</td>
</tr>

<tr>
<td class="org-left">offsets.topic.segment.bytes</td>
<td class="org-left">int(104857600)</td>
<td class="org-left">offsets 分段的大小，超过会新建文件。</td>
</tr>

<tr>
<td class="org-left">queued.max.requests</td>
<td class="org-left">int(500)</td>
<td class="org-left">当网络进程阻塞时，允许的加入队列的请求数量。</td>
</tr>

<tr>
<td class="org-left">replica.fetch.min.bytes</td>
<td class="org-left">int(1)</td>
<td class="org-left">每个期望的fetch响应比特数，如果未到等待时间replicaMaxWaitTimeMs.</td>
</tr>

<tr>
<td class="org-left">replica.fetch.wait.max.ms</td>
<td class="org-left">int(500)</td>
<td class="org-left">follower向每个fetcher请求复制时等待相应的最大时间。这个值应该比replica.lag.time.max.ms小, 避免低流通的时候就出现ISR的频繁收缩。</td>
</tr>

<tr>
<td class="org-left">replica.high.watermark.checkpoint.interval.ms</td>
<td class="org-left">long(5000)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">replica.lag.time.max.ms</td>
<td class="org-left">long(10000)</td>
<td class="org-left">如果一个follower在这个时间内都没有向leader发送fetcher请求或者消费leader数据， **leader就会将其从ISR中剔除**。</td>
</tr>

<tr>
<td class="org-left">replica.socket.receive.buffer.bytes</td>
<td class="org-left">int(65536)</td>
<td class="org-left">socket接受网络请求的buffer</td>
</tr>

<tr>
<td class="org-left">replica.socket.timeout.ms</td>
<td class="org-left">int(30000)</td>
<td class="org-left">网络请求的socket延时，值应该不小于replica.fetch.wait.max.ms</td>
</tr>

<tr>
<td class="org-left">request.timeout.ms</td>
<td class="org-left">int(30000)</td>
<td class="org-left">客户端等待请求的最大时间，如果过了这段时间客户端没有得到请求，客户端有必要可以重发请求，或者定义为请求失败。</td>
</tr>

<tr>
<td class="org-left">socket.receive.buffer.bytes</td>
<td class="org-left">int(102400)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">socket.request.max.bytes</td>
<td class="org-left">int(104857600)</td>
<td class="org-left">socket请求的最大字节数。</td>
</tr>

<tr>
<td class="org-left">socket.send.buffer.bytes</td>
<td class="org-left">int(102400)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">unclean.leader.election.enable</td>
<td class="org-left">bool(true)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">zookeeper.connect</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">zookeeper.connection.timeout.ms</td>
<td class="org-left">int(null)</td>
<td class="org-left">客户端和zk建立链接的最长时间。未设置是使用 zookeeper.session.timeout.ms</td>
</tr>

<tr>
<td class="org-left">zookeeper.session.timeout.ms</td>
<td class="org-left">int(6000)</td>
<td class="org-left">Zookeeper session timeout</td>
</tr>

<tr>
<td class="org-left">zookeeper.set.acl</td>
<td class="org-left">bool(false)</td>
<td class="org-left">设置client是否使用ACLs</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-orge0d97e0" class="outline-2">
<h2 id="orge0d97e0">名词</h2>
<div class="outline-text-2" id="text-orge0d97e0">
</div>
<div id="outline-container-org641407f" class="outline-3">
<h3 id="org641407f">日志聚合 log aggregation</h3>
<div class="outline-text-3" id="text-org641407f">
<p>
日志聚合一般来说是从服务器上收集日志文件，然后放到一个集中的位置（文件服务器或 HDFS）进行处理。
</p>
</div>
</div>

<div id="outline-container-orgcaea7d8" class="outline-3">
<h3 id="orgcaea7d8">页缓存 pagecache</h3>
<div class="outline-text-3" id="text-orgcaea7d8">
<p>
将文件页缓存到内存中，方便下次直接从内存中读取。
</p>

<p>
<a href="https://www.thomas-krenn.com/en/wiki/Linux_Page_Cache_Basics">Linux Page Cache Basics</a>
</p>

<ul class="org-ul">
<li>文件 cache</li>
</ul>
<p>
<a href="https://www.ibm.com/developerworks/cn/linux/l-cache/">Linux 内核的文件 Cache 管理机制介绍</a>
</p>

<p>
本文中提到："操作系统是计算机上最重要的系统软件，它负责管理各种物理资源，并向应用程序提供各种抽象接口以
便其使用这些物理资源。从应用程序的角度看，操作系统提供了一个统一的虚拟机，在该虚拟机中没有各种机器的具
体细节，只有进程、文件、地址空间以及进程间通信等逻辑概念。"
我对这里说的操作系统在应用层面上可以看做一个虚拟机的观点理解：操作系统是封装了对计算机硬件的使用该接口，
我们通过操作系统传达我们的需要给硬件而驱动计算机硬件的工作。我们要操作的实际是真是的物理机器，而直接操作
的是操作系统，所以从我们应用层面来说，操作系统就是物理机器的虚拟。
</p>

<ul class="org-ul">
<li>虚拟文件系统 VFS</li>
</ul>
<p>
<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-vfs/">从文件 I/O 看 Linux 的虚拟文件系统</a>
</p>

<p>
虚拟文件系统（Virtual File System, 简称 VFS）， 是 Linux 内核中的一个软件层，用于给用户空间的程序提供文
件系统接口；同时，它也提供了内核中的一个 抽象功能，允许不同的文件系统共存。系统中所有的文件系统不但依赖 
VFS 共存，而且也依靠 VFS 协同工作。
</p>
</div>
</div>
</div>

<div id="outline-container-orgc77dbe9" class="outline-2">
<h2 id="orgc77dbe9">reference</h2>
<div class="outline-text-2" id="text-orgc77dbe9">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><a href="http://zqhxuyuan.github.io/2017/01/01/Kafka-Code-Index/">Kafka 技术内幕</a></td>
</tr>

<tr>
<td class="org-left"><a href="http://www.jasongj.com/2015/01/02/Kafka%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/">Kafka深度解析</a></td>
</tr>

<tr>
<td class="org-left"><a href="http://www.jianshu.com/p/8a61bb2a9219">zookeeper在Kafkaf中的作用</a></td>
</tr>
</tbody>
</table>
</div>
</div>


<div id="outline-container-org763090b" class="outline-2">
<h2 id="org763090b">kafka在zk中的目录</h2>
<div class="outline-text-2" id="text-org763090b">
<p>
zk中的目录结构和算法用于协调消费者和kafka节点。
</p>


<div id="orgbe83511" class="figure">
<p><img src="/assets/blog/2016/11/07/kafka-usage/zk_kafka_register.png" alt="zk_kafka_register.png" />
</p>
<p><span class="figure-number">Figure 6: </span>brokers in zk</p>
</div>

<p>
[zk: 192.168.0.45:2181(CONNECTED) 40] ls /
[cluster, controller_epoch, controller, brokers, zookeeper, kafka-manager, admin, isr_change_notification, consumers, config]
</p>
</div>

<div id="outline-container-org0f974f7" class="outline-3">
<h3 id="org0f974f7">brokers注册</h3>
<div class="outline-text-3" id="text-org0f974f7">
<ul class="org-ul">
<li>或者的brokers列表，唯一的id，消费者从这里获取broker的信息。</li>
<li>brokers启动是注册(创建目录)，shutdown和die时消失，消费者得到通知。（暂态的）</li>
</ul>
</div>
</div>

<div id="outline-container-org94e3f98" class="outline-3">
<h3 id="org94e3f98">brokers上的topic注册</h3>
<div class="outline-text-3" id="text-org94e3f98">
<ul class="org-ul">
<li>该broker上的topic信息。</li>
<li>也是暂态的。</li>
<li><i>brokers/topics</i>[topic]/partitions/[0...N]/state</li>
</ul>
</div>
</div>

<div id="outline-container-org13173c0" class="outline-3">
<h3 id="org13173c0">consumer Id注册</h3>
<div class="outline-text-3" id="text-org13173c0">
<ul class="org-ul">
<li>协调彼此，均衡数据的消费</li>
<li>通过配置offsets.storage=zookeeper将offsets信息存在zookeepker上。但该机制会被废除，建议放到kafka上。</li>
<li><i>consumer</i>[group_id]/ids/[consumer_id]， 暂态的，如果consumer挂了就会消失。</li>
</ul>
</div>
</div>

<div id="outline-container-org6b25c30" class="outline-3">
<h3 id="org6b25c30">consumer offset</h3>
<div class="outline-text-3" id="text-org6b25c30">
<ul class="org-ul">
<li><i>consumers</i>[group_id]/offsets/[topic]/[partition_id] --&gt; offset_counter_value， 这个是永久值。</li>
<li>记录某个消费组消费某个topic的某个分区的offset。</li>
</ul>
</div>
</div>

<div id="outline-container-orgee00502" class="outline-3">
<h3 id="orgee00502">分区消费者注册</h3>
<div class="outline-text-3" id="text-orgee00502">
<ul class="org-ul">
<li>一个分区只能被一个消费组的一个consumer消费。</li>
<li><i>consumers</i>[group_id]/owners/[topic]/[partition_id] --&gt; consumer_node_id (ephemeral node)</li>
<li>该注册信息是暂态的，旧的consumer挂了，或者新增consumer，可能会均衡到其他consumer去消费。</li>
</ul>
</div>
</div>

<div id="outline-container-org4f99545" class="outline-3">
<h3 id="org4f99545">Cluster Id</h3>
<div class="outline-text-3" id="text-org4f99545">
<ul class="org-ul">
<li>/cluster/id</li>
<li>每个kafka cluster再zk上有一个唯一不变的集群id。这个id集群第一次启动后自动产生。broker启动后会从/cluster/id这个znode上获取，如果没有就新建。</li>
</ul>
</div>
</div>

<div id="outline-container-org090da7d" class="outline-3">
<h3 id="org090da7d">Broker node 注册</h3>
<div class="outline-text-3" id="text-org090da7d">
<ul class="org-ul">
<li>前面broker下面的其实就是broker注册信息。</li>
<li>broker本质上是独立的，他们只发布他们有点信息。</li>
<li>当一个新的broker加入集群，不仅会注册自己的，还会把broker上的topic信息也一起注册。</li>
<li>新的topic产生之后也会将topic的信息注册在broker下面。</li>
</ul>
</div>
</div>

<div id="outline-container-org558d333" class="outline-3">
<h3 id="org558d333">消费者注册算法</h3>
<div class="outline-text-3" id="text-org558d333">
<p>
步骤：
</p>
<ul class="org-ul">
<li>注册自己在/consumer/[group_id]/ids/[id]下，内容包括{"pattern":"static","subscription":{"intoyun-info-message":1},"timestamp":1494398431,"version":1}</li>
<li>在consumer id下注册注册一个watcher，监控消费者的加入或者移除的变化。每次变化都会触发组内消费者的重新均衡。</li>
<li>在broker id下注册一个watcher，监控broker的加入和移除，每次broker的变化都会触发所有消费组中所有consumer的重新均衡。</li>
<li>如果消费者创建了一个消息流（就是消费一个topic，又将处理后的数据发送另一个topic），他也会再broker id下注册一个watcher监控新加入的topic。进而触发可得topics的一些列动作。</li>
<li>强制消费组内的consumers重新均衡。</li>
</ul>
</div>
</div>

<div id="outline-container-org4765a42" class="outline-3">
<h3 id="org4765a42">消费者再均衡算法</h3>
<div class="outline-text-3" id="text-org4765a42">
<p>
当出现broker的变化或者消费组内consumer的变化都会触发consumers的再均衡。对于一个给定的topic和已知的消费者，broker上的分区都会均衡的分配给组内的consumers消费。
</p>

<p>
一个分区只能被一个组内的消费者消费，这样简化了运用，否则，分区上还需要很多的锁。再均衡的时候，通过下面的方法将一个分区分配给消费者，这样可以减少每个消费者连接的broker个数：
</p>

<ul class="org-ul">
<li>对于消费者组CG=[C0, C1, ...,], topic的分区PT=[P0, P1,...];</li>
<li>N = size(PT)/size(CG);(向上取整)</li>
<li>分配Ci消费i*N到(i+1)*N-1;</li>
<li>分配完之后删除当前的消费关系;</li>
<li>新加入分区之后重新均衡。</li>
</ul>

<p>
比如：10个分区[P0~P9]，3个消费者[C0~C2]； N = 10/3=4， 那么：
C0消费0*4~(0+1)*4-1，即0~3；
C1消费1*4~(1+1)*4-1，即4~7；
C2消费2*4~(2+1)*4-1，即8~11(8~9)；
</p>

<p>
再比如：6个分区[P0~P5]，5个消费者[C0~C4]； N = 6/5=2， 那么：
C0消费0*2~(0+1)*2-1，即0~1；
C1消费1*2~(1+1)*4-1，即2~3；
C2消费2*2~(2+1)*4-1，即4~5；
C3消费3*2~(3+1)*4-1，即empty；
C4消费4*2~(4+1)*4-1，即empty；
</p>

<p>
这样就有两个worker占用资源但是闲置了。
</p>

<p>
因此：
</p>
<ul class="org-ul">
<li>按照如上的算法，所以如果kafka的消费组需要增加组员，最多增加到和partition数量一致，超过的组员只会占用资源，而不起作用；</li>
<li>kafka的partition的个数一定要大于消费组组员的个数，并且partition的个数对于消费组组员取模一定要为0，不然有些消费者会占用资源却不起作用；</li>
<li>如果需要增加消费组的组员个数，那么也需要根据上面的算法，调整partition的个数</li>
</ul>

<p>
但是如果offset再zk上，以上规则不一定适合。
</p>
</div>
</div>

<div id="outline-container-org5e8f9fd" class="outline-3">
<h3 id="org5e8f9fd">kafka broker的节点注册</h3>
<div class="outline-text-3" id="text-org5e8f9fd">
<p>
保存或者的broker信息。
</p>

<p>
broker启动之后，会在zk上/brokers/ids目录下创建一个znode来注册自己的信息。每个broker都会提供一个唯一的逻辑id，消费者会识别这个id，并从这个获取到这个broker的基本配置。
这个逻辑Id的作用是broker被移动到另一个机器上之后，不会对消费者产生影响。如果注册的ID已经存在就会报错。
</p>

<p>
broker在zk上的注册信息是暂时的，一旦broker关闭或挂掉，这些注册信息就会消失，这样会告诉消费者该broker已经挂了。
</p>

<p>
如下:
这个znode的值包括:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">"listener_security_protocol_map"</td>
<td class="org-left">{"PLAINTEXT":"PLAINTEXT"}</td>
</tr>

<tr>
<td class="org-left">"endpoints"</td>
<td class="org-left">["PLAINTEXT://192.168.0.45:9093"]</td>
</tr>

<tr>
<td class="org-left">"jmx_port"</td>
<td class="org-left">9999</td>
</tr>

<tr>
<td class="org-left">"host"</td>
<td class="org-left">"192.168.0.45"</td>
</tr>

<tr>
<td class="org-left">"timestamp"</td>
<td class="org-left">"1494377317378"</td>
</tr>

<tr>
<td class="org-left">"port"</td>
<td class="org-left">9093</td>
</tr>

<tr>
<td class="org-left">"version"</td>
<td class="org-left">4</td>
</tr>
</tbody>
</table>

<div class="org-src-container">
<pre class="src src-text">[zk: 192.168.0.45:2181(CONNECTED) 6] get /brokers/ids/0
{"listener_security_protocol_map":{"PLAINTEXT":"PLAINTEXT"},"endpoints":["PLAINTEXT://192.168.0.45:9093"],"jmx_port":9999,"host":"192.168.0.45","timestamp":"1494377317378","port":9093,"version":4}
cZxid = 0x50000000f
ctime = Wed May 10 08:48:37 CST 2017
mZxid = 0x50000000f
mtime = Wed May 10 08:48:37 CST 2017
pZxid = 0x50000000f
cversion = 0
dataVersion = 0
aclVersion = 0
ephemeralOwner = 0x25befd4048b0001
dataLength = 196
numChildren = 0
</pre>
</div>
</div>
</div>

<div id="outline-container-org0aef798" class="outline-3">
<h3 id="org0aef798">broker topic的注册</h3>
<div class="outline-text-3" id="text-org0aef798">
<p>
<i>brokers/topics</i>[topic]/partitions/[0...N]/state --&gt; {"controller_epoch":...,"leader":...,"version":...,"leader_epoch":...,"isr":[...]} (ephemeral node)
</p>

<p>
每个broker都会注册在该broker上的所有topic信息，包括topic，分区，每个分区的state，
</p>
</div>
</div>
</div>

<div id="outline-container-org74e7806" class="outline-2">
<h2 id="org74e7806">references</h2>
<div class="outline-text-2" id="text-org74e7806">
<ul class="org-ul">
<li>Apache Kafka Best Practices 
<a href="https://www.slideshare.net/HadoopSummit/apache-kafka-best-practices">https://www.slideshare.net/HadoopSummit/apache-kafka-best-practices</a></li>

<li>Kafka Best Practices
<a href="https://community.hortonworks.com/articles/80813/kafka-best-practices-1.html">https://community.hortonworks.com/articles/80813/kafka-best-practices-1.html</a></li>

<li>How many topics can be created in Apache Kafka?
<a href="https://www.quora.com/How-many-topics-can-be-created-in-Apache-Kafka">https://www.quora.com/How-many-topics-can-be-created-in-Apache-Kafka</a></li>

<li>某互联网大厂kafka最佳实践
<a href="http://www.jianshu.com/p/8689901720fd">http://www.jianshu.com/p/8689901720fd</a></li>
</ul>
</div>
</div>


      </article>
      <div>
    <ul id="tags">
        <li><a href="/tags/services/">services</a></li>
    </ul>
    <div class="post-meta">
      <span title="post date">Published: 2016-11-07</span>
      </br>
      <span title="last modification date">Last Modification: 2020-08-14</span>
      </br>
      <span title="author" >Author: Xuancong Lee</span>
    </div>
    <section>
      <h2>Comments</h2>
        <div id="disqus_thread"></div>
        <script type="text/javascript">
        //var disqus_developer = 1;
        var disqus_identifier = "/blog/2016/11/07/kafka-usage";
        var disqus_url = "https://congleetea.github.io/blog/2016/11/07/kafka-usage";
        var disqus_shortname = 'congleetea';
        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="//disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </section>
  <script src="//code.jquery.com/jquery-latest.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.1.0/highlight.min.js"></script>
  <script src="/media/js/main.js"></script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <div class="copyright">
    <p>Generated by <a href="http://www.gnu.org/software/emacs/">Emacs</a> 25.x (<a href="http://orgmode.org">Org mode</a> 9.x)</p>
    <p>
      Copyright &copy; 2012 - <span id="footerYear"></span> <a href="mailto:congleetea &lt;at&gt; gmail &lt;dot&gt; com">Xuancong Lee</a>
      &nbsp;&nbsp;-&nbsp;&nbsp;
      Powered by <a href="https://github.com/kelvinh/org-page" target="_blank">org-page</a>
      <script type="text/javascript">document.getElementById("footerYear").innerHTML = (new Date()).getFullYear();</script>
    </p>
  </div>
</div>

    </div>
  </body>
</html>
